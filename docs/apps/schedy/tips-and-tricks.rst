Tips & Tricks
=============

The purpose of this page is to collect useful configuration snippets and
tips for using Schedy in various (maybe not so common) usage scenarios.


Schedule Rules with Dynamic Start and End Times
-----------------------------------------------

The start and end time of a schedule rule are always static. They can't
be computed by something like expressions at runtime. However, there is
a trick you can utilize in order to get start and end times which are
based on the state of entities in Home Assistant.

Let's assume you've got two entities, ``input_number.start_hour`` and
``input_number.end_hour``. Then you could write a schedule rule without
the ``start`` and ``end`` fields set, resulting in it always being valid.
As the value for ``x``, you configure an expression like the following.

::

    "on" if time.hour >= float(state("input_number.start_hour")) and time.hour <= float(state("input_number.end_hour")) else Skip()

What this does is quite simple. It sets the value to "on" if the
current hour is between the values configured by the two entities we
introduced. If it's not, the rule is ignored and processing continues
at the next rule, as always.

There is still one thing missing in order to make this work properly. You
need to notify Schedy about state changes of the used entities by firing
an event. How that's done is described at the end of :ref:`this example
<schedy/expressions/examples/inlining-expressions-into-schedules>`.

You could now make the temperature configurable via an
``input_number.day_temperature`` entity as well.

Now let's put this all together into a valid schedule rule:

::

    - v: state("input_number.day_temperature") if time.hour >= float(state("input_number.start_hour")) and time.hour <= float(state("input_number.end_hour")) else Skip()


Reacting to Changes of Schedy's State
-------------------------------------

Each room records its state to an entity in Home Assistant. This entity
is named ``schedy_room.<app name>_<room name>``.

The state of such an entity is the value currently set for the
room. Since values can be changed manually, this is not necessarily the
one generated by the schedule. The actual scheduled value is stored as
the ``scheduled_value`` attribute of the entity.

You can use normal Home Assistant automations to react to changes of
these entities.


.. _schedy/tips-and-tricks/open-door-or-window-detection:

Open Door or Window Detection
-----------------------------

When using Schedy for heating control and you've got window sensors, you
might want to have the thermostats in a room turned off when a window
is opened. We can achieve this with a single additional schedule rule
and one automation in Home Assistant for an unlimited number of windows.

We assume that our window sensors are named
``binary_sensor.living_window_1`` and ``binary_sensor.living_window_2``
and report ``"on"`` as their state when the particular window is opened.

To make this solution scale to multiple windows in multiple rooms without
creating additional automations or rules, we add a new custom attribute
to our window sensors via the ``customize.yaml`` file that holds the
name of the Schedy room the sensor belongs to.

::

    binary_sensor.living_window_1:
      window_room: living

    binary_sensor.living_window_2:
      window_room: living

Now, a new rule which overlais the temperature with ``OFF`` when a window
in the current room is open is added. We place it at the top of the
``schedule_prepend`` configuration section to have it applied to all
rooms as their first rule.

This code checks all ``binary_sensor`` entities found in Home Assistant
for a ``window_room`` attribute with the current room's name as its
value and a state of ``"on"``. This way it finds all window sensors of
the current room that report to be open. The ``is_empty()`` function is
used with the ``filter_entities()`` generator to have searching aborted as
soon as one open window is found rather than always checking all entities.
Feel free to break this single-line expression into multiple statements
if you prefer clarity over conciseness.

::

    - x: Mark(OFF, Mark.OVERLAY) if not is_empty(filter_entities("binary_sensor", window_room=room_name, state="on")) else Skip()

Now, we add an automation to re-evaluate the schedule when a window's
state changes. Replace ``schedy_heating`` with the name of your
instance of Schedy. In order to add more window sensors, just append
them to the ``entity_id`` list and set the ``window_room`` attribute in
``customize.yaml`` to the room the particular sensor belongs to.

::

    - alias: schedy heating open window detection
      trigger:
      - platform: state
        entity_id:
        - binary_sensor.living_window_1
        - binary_sensor.living_window_2
      condition:
      - condition: template
        value_template: "{{ trigger.from_state.state != trigger.to_state.state }}"
      action:
      - event: schedy_reschedule
        event_data_template:
          app_name: schedy_heating
          room: "{{ trigger.to_state.attributes['window_room'] }}"

That's it. Don't forget to restart Home Assistant after editing the files.


Motion-Triggered Lights
-----------------------

Scheduling lights is really easy with the ``switch`` actor type. Even
associating motion sensors isn't too complicated with just a single
automation and an additional schedule rule. The procedure is identical to
that used for :ref:`schedy/tips-and-tricks/open-door-or-window-detection`,
except that the ``binary_sensor`` entities now report motion instead
of open windows and the value needs to be set to ``"on"`` while motion
is detected.

Let's assume the following:

1. You've got a room named ``entrance`` configured in Schedy with one
   or more lights as actors.

2. There'S a motion sensor ``binary_sensor.entrance_motion`` that switches
   to ``on`` when motion is detected.

Ok, let's get started.

1. Add a custom ``motion_room: entrance`` attribute to the
   ``binary_sensor.entrance_motion`` entity via ``customize.yaml``
   to tie the motion sensor to the Schedy room it belongs to.

2. Now, a new rule which overlais the value with ``"on"`` while a
   motion sensor of the current room reports motion is added. We place
   it at the top of the ``schedule_prepend`` configuration section to
   have it applied to all rooms as their first rule.

   ::

       - x: Mark("on", Mark.OVERLAY) if not is_empty(filter_entities("binary_sensor", motion_room=room_name, state="on")) else Skip()

3. Create an automation.

   ::

       - trigger:
         - platform: state
           entity_id:
           - binary_sensor.entrance_motion
           # add all motion sensors of all rooms here
         condition:
         - condition: template
           value_template: "{{ trigger.from_state.state != trigger.to_state.state }}"
         action:
         - event: schedy_reschedule
           event_data_template:
             app_name: schedy_light
             room: "{{ trigger.to_state.attributes['motion_room'] }}"

Try it out. As long as at least one of the motion sensors in a room
reports motion, the lights in that room should stay on.

If you also had brightness sensors in each room, you could now insert
another rule before the one we just added to fix the value to ``"off"``
when it's not dark enough in the particular room.
