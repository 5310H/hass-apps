Writing Expressions
===================

.. note::

   In contrast to plain values, which are denoted as ``value`` or ``v``,
   expressions have to be set as the ``expression`` (or ``x``) parameter
   of a schedule rule. And since expressions have to be strings, we
   enclose them in quotation marks to prevent the YAML parser from
   guessing, which may otherwise lead to obscure errors with certain
   expressions.

Expressions must return a kind of value the used actor type
understands. Take the thermostat actor as an example. It needs a
temperature value which can either be an integer (``19``) or floating
point value (``20.5``).


Expressions vs. Statements
--------------------------

The string provided as the ``x`` parameter of a schedule rule is
treated as a simple Python expression. Each of the following is a valid
expression.

* ``5``
* ``True``
* ``'off'``
* ``17 if is_on('binary_sensor.absent') else Skip()``

Writing expressions that way is short and great for things like binary
decisions. However, there might be situations in which you need to make
more complex weightings that would get confusing when written as a single
line expression. That's why you may as well use whole statements.

As soon as the string given as an expression contains line-breaks,
it's treated as a series of whole statements rather than an expression. In
YAML, a schedule rule with such a multi-line expression can be denoted
as follows.

::

    - x: |
        a = 2
        b = 5
        result = a * b

The string is introduced by a ``|``, and all following lines need to be
indented by a custom (but consistent) number of spaces.

You may in fact write  arbitrary Python code in such a script, including
import statements and class or function definitions. The only requirement
is that at the end of the execution, the final result is stored in the
global ``result`` variable.

.. note::

   The string really has to consist of more than one line to be treated
   as a statement. The following example doesn't contain line-breaks
   and hence would be considered as an uncompilable expression.

   ::

       - x: |
           result = 42

   While this is a valid single-line expression and would compile just fine:

   ::

       - x: |
           42


Controlling the Evaluation Flow
-------------------------------

There are special types  available for creating objects you can return
from an expression in order to influence the way your schedule is
processed.

* ``Abort()``, which causes schedule lookup to be aborted immediately.
  The value will not be changed in this case.
* ``Break(levels=1)``, which causes lookup of one (or multiple nested)
  sub-schedule(s) to be aborted immediately. The evaluation will continue
  after the sub-schedule(s).
* ``IncludeSchedule(schedule)``, which evaluates the given schedule
  object. See below for an example on how to use this.
* ``Skip()``, which causes the rule to be treated as if it didn't exist
  at all. If one exists, the next rule is evaluated in this case.


Preliminary Results
-------------------

.. include:: /advanced-topic.rst.inc

There are situations in which it would come handy to add something to
the later result of scheduling without knowing what that result will
actually be. One such situation for the thermostat actor type is lowering
the temperature by a certain number of degrees when nobody is home. For
such needs, there is a concept called preliminary results.

In the evaluation environment, there are a number of types that can be
used to tell Schedy you want to generate a preliminary result that isn't
final yet. Namely, there are:

* ``Add(x)`` to add a value ``x`` to the final result.
* ``And(x)`` to combine the final result with ``x`` by the ``and``
  Python operator.
* ``Multiply(x)`` to multiply the final result with ``x``.
* ``Negate()`` to negate the final result. This negates numbers,
  inverts boolean values and swaps the strings ``"on"`` and ``"off"``
  for each other.
* ``Or(x)`` to combine the final result with ``x`` by the ``or``
  Python operator.

When an expression results in such a preliminary value, the value is
stored until a subsequent rule results in something final. Then, the
stored preliminary values are applied to that result one by one in the
order they were generated.


Result Markers
--------------

.. include:: /advanced-topic.rst.inc

A result generated by an expression can optionally be marked with some
pre-defined markers that influence how the result is handled.

Instead of

::

    - x: "21"

you write

::

    - x: Mark(21, Mark.OVERLAY)

to mark the result ``21`` with the ``OVERLAY`` marker.

The actual syntax is ``Mark(result, marker1, ..., markerN)``, so you
can add multiple markers ad once. Markers can be applied to preliminary
results as well, but they will be used for the final result.

The following markers are available:

* ``OVERLAY``: Overwrite manual value adjustments even when a configured
  ``rescheduling_delay`` would normally have prevented it.
  As soon as the schedule no longer evaluates to an ``OVERLAY``-marked
  result the previous value is restored, no matter if that was the
  scheduled or a manually set one. Even a previous re-scheduling time
  is restored.
  An occasion for using this marker is
  :doc:`../tips-and-tricks/open-window-detection`.


Expressions and Sub-Schedules
-----------------------------

.. include:: /advanced-topic.rst.inc

In general, there is no difference between using plain values and advanced
expressions in both rules with a sub-schedule attached to them (so-called
sub-schedule rules) and the rules contained in these sub-schedules. But
with expressions, you gain a lot more flexibility.

As you know from :ref:`schedy/writing-schedules/rules-with-sub-schedules`,
rules of sub-schedules inherit their ``v`` parameter from the nearest
anchestor rule having it defined, should they miss an own one. Basically,
this is true for the ``x`` parameter as well.

With an expression as the ``x`` value of the rule having a sub-schedule,
you get the flexibility to dynamically overwrite the anchestor's value or
expression. Should an expression return ``None``, the next anchestor's
value or expression is tried to be used. When compared to plain values,
returning ``None`` is the equivalent of omitting the ``v`` parameter
completely, but with the benefit of deciding dynamically about whether
to omit it or not.

The whole process can be described as follows. To find the result for
a particular rule inside a sub-schedule, the ``v``/``x`` parameters of
the rule and it's anchestor rules are evaluated from inside to outside
(from right to left when looking at the indentation of the YAML syntax)
until one results in something different to ``None``.
