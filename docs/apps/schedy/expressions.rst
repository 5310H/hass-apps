Expressions
===========

Schedy accepts so called expressions in schedules or when manually
setting a value via the ``schedy_set_value`` event.

Expressions are a powerful way of expressing a value to be sent to
actors in relation to anything you can think of. This power comes from
the fact that expressions are just normal Python code which is evaluated
at runtime. When Schedy parses its configuration, all expressions found
in schedules are pre-compiled to make their later evaluation really
performant.

Expressions must return a kind of value the used actor type
understands. Looking at the thermostat actor which needs temperature
values, such an object can be created as a plain integer or floating
point value like ``19`` or ``20.5``. The special value ``OFF`` is also
available for thermostats.


The Execution Environment
-------------------------

There is an object available under the name ``app`` which represents
the ``appdaemon.plugins.hass.hassapi.Hass`` object of Schedy. You could,
for instance, retrieve values of input sliders via the normal AppDaemon
API.

The following globals are available for use in expressions.

* ``room_name``: the name of the room the expression is evaluated for
  as set in Schedy's configuration (not the friendly name)
* ``schedule_snippets``: a dictionary containing all configured schedule
  snippets, indexed by their name for use with ``IncludeSchedule()``

* date and time:

  * ``datetime``: Python's ``datetime`` module
  * ``now``: a ``datetime.datetime`` object containing the current date
    and time
  * ``date``: a shortcut for ``now.date()``
  * ``time``: a shortcut for ``now.time()``

* state:

  * ``app``: the ``appdaemon.plugins.hass.hassapi.Hass`` object of Schedy
  * ``is_on(entity_id)``: returns ``True`` if the state of the given entity
    is ``"on"`` (case-insensitive), ``False`` otherwise
  * ``is_off(entity_id)``: returns ``True`` if the state of the given entity
    is ``"off"`` (case-insensitive), ``False`` otherwise
  * ``state(entity_id, attribute=None)``: a shortcut for ``app.get_state(entity_id, attribute=None)``

.. note::

   There is a difference between using ``is_off(...)`` and ``not
   is_on(...)``. These helper functions only compare the state of the
   specified entity to the values ``"off"`` and ``"on"``, respectively. If
   you want to treat a non-existing entity (which's state is returned as
   ``None``) as if it was ``"off"``, you have to use ``not is_on(...)``
   since ``is_off(...)`` would return ``False`` in this case.


Controlling the Evaluation Flow
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are special types  available for creating objects you can return
from an expression in order to influence the way your schedule is
processed.

* ``Abort()``, which causes schedule lookup to be aborted immediately.
  The value will not be changed in this case.
* ``Break(levels=1)``, which causes lookup of one (or multiple nested)
  sub-schedule(s) to be aborted immediately. The evaluation will continue
  after the sub-schedule(s).
* ``IncludeSchedule(schedule)``, which evaluates the given schedule
  object. See below for an example on how to use this.
* ``Skip()``, which causes the rule to be treated as if it didn't exist
  at all. If one exists, the next rule is evaluated in this case.


Preliminary Results
~~~~~~~~~~~~~~~~~~~

.. include:: advanced-topic.rst.inc

There are situations in which it would come handy to add something to
the later result of scheduling without knowing what that result will
actually be. One such situation for the thermostat actor type is lowering
the temperature by a certain number of degrees when nobody is home. For
such needs, there is a concept called preliminary results.

In the evaluation environment, there are a number of types that can be
used to tell Schedy you want to generate a preliminary result that isn't
final yet. Namely, there are:

* ``Add(x)`` to add a value ``x`` to the final result.
* ``And(x)`` to combine the final result with ``x`` by the ``and``
  Python operator.
* ``Multiply(x)`` to multiply the final result with ``x``.
* ``Negate()`` to negate the final result. This negates numbers,
  inverts boolean values and swaps the strings ``"on"`` and ``"off"``
  for each other.
* ``Or(x)`` to combine the final result with ``x`` by the ``or``
  Python operator.

When an expression results in such a preliminary value, the value is
stored until a subsequent rule results in something final. Then, the
stored preliminary values are applied to that result one by one in the
order they were generated.


Result Markers
~~~~~~~~~~~~~~

.. include:: advanced-topic.rst.inc

A result generated by an expression can optionally be marked with some
pre-defined markers that influence how the result is handled.

Instead of

::

    - x: "21"

you write

::

    - x: Mark(21, Mark.OVERLAY)

to mark the result ``21`` with the ``OVERLAY`` marker.

The following markers are available:

* ``OVERLAY``: Overwrite manual value adjustments even when a configured
  ``rescheduling_delay`` would normally have prevented it.
  As soon as the schedule again evaluates to the previous result without
  the ``OVERLAY`` marker set, the previous value is restored, no matter
  if that was the scheduled or a manually set one. Even a previous
  re-scheduling time is restored.
  An occasion for using this marker is `Open Door or Window Detection
  <tips-and-tricks.html#open-door-or-window-detection>`_.


Expressions vs. Statements
--------------------------

The string provided as the ``x`` parameter of a schedule rule is
treated as a simple Python expression. Each of the following is a valid
expression.

* ``5``
* ``True``
* ``"off"``
* ``17 if is_on("binary_sensor.absent") else Skip()``

Writing expressions that way is short and great for things like binary
decisions. However, there might be situations in which you need to make
more complex weightings that would get confusing when written as a single
line expression. That's why you may as well use whole statements.

As soon as the string given as an expression contains line-breaks, it's
treated as a series of whole statements rather than an expression. In
YAML, a schedule rule with such a multi-line expression can be denoted
as follows.

::

    - x: |
        a = 2
        b = 5
        result = a * b

The string is introduced by a ``|``, and all following lines need to be
indented by a custom (but consistent) number of spaces.

You may in fact write  arbitrary Python code in such a script, including
import statements and class or function definitions. The only requirement
is that at the end of the execution, the final result is stored in the
global ``result`` variable.


Expressions and Sub-Schedules
-----------------------------

.. include:: advanced-topic.rst.inc

In general, there is no difference between using plain values and advanced
expressions in both rules with a sub-schedule attached to them (so-called
sub-schedule rules) and the rules contained in these sub-schedules. But
with expressions, you gain a lot more flexibility.

As you know from the `chapter about sub-schedules
<writing-schedules.html#rules-with-sub-schedules>`_, rules of
sub-schedules inherit their ``v`` parameter from the nearest anchestor
rule having it defined, should they miss an own one.

With an expression as the ``x`` value of the rule having a sub-schedule,
you get the flexibility to dynamically overwrite the anchestor's value or
expression. Should an expression return ``None``, the next anchestor's
value or expression is tried to be used. When compared to plain values,
returning ``None`` is the equivalent of omitting the ``v`` parameter
completely, but with the benefit of deciding dynamically about whether
to omit it or not.

The whole process can be described as follows. To find the result for
a particular rule inside a sub-schedule, the ``v``/``x`` parameters of
the rule and it's anchestor rules are evaluated from inside to outside
(from right to left when looking at the indentation of the YAML syntax)
until one results in something different than ``None``.


Examples
--------

Example: Inlining Expressions into Schedules
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's say we use the thermostat actor type and have a switch
that should prepare our bathroom for taking a bath. It's name is
``switch.take_a_bath``. We write the following schedule for the room
``bathroom``.

::

    schedule:
    - x: 22 if is_on("switch.take_a_bath") else Skip()
    - v: 19

Last step is to write a simple Home Assistant automation to emit
a re-schedule event whenever the state of ``switch.take_a_bath``
changes. More about the available events and how to emit them is explained
in `this chapter <events.html>`_.

::

    - alias: "Re-schedule when switch.take_a_bath is toggled"
      trigger:
      - platform: state
        entity_id: switch.take_a_bath
      action:
      - event: schedy_reschedule
        event_data:
          app_name: <name of your schedy instance>
          room: bathroom

We're done! Now, whenever we toggle the ``take_a_bath`` switch, the
schedule is re-evaluated and our first schedule rule executes. The
rule is evaluating our custom expression, checking the state of the
``take_a_bath`` switch and, if it's enabled, causes the temperature to
be set to 22 degrees. However, if the switch is off, the rule is ignored
completely due to the ``Skip()`` we return in that case.

If that happens, the second rule is processed, which always evaluates
to 19 degrees.


Example: Use of ``Add()`` and ``Skip()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is a rule I once used in my own heating configuration at home:

::

    schedule_prepend:
    - x: Add(-3) if is_on("input_boolean.absent") else Skip()

What does this? Well, the first thing we see is that the rule is placed
inside the ``schedule_prepend`` section. That means, it is valid for
every room and always the first rule being evaluated.

I've defined an ``input_boolean`` called ``absent`` in Home
Assistant. Whenever I leave the house, this gets enabled. If I return,
it's turned off again. In order for Schedy to notice the toggling, I
added an automation to Home Assistant which fires a ``schedy_reschedule``
event. How that can be done has already been shown above.

Now let's get back to the schedule rule. When it evaluates, it checks the
state of ``input_boolean.absent``. If the switch is turned on, it
evaluates to ``Add(-3)``, otherwise to ``Skip()``.

As you know from above, ``Add(-3)`` is no final result yet. Think of it
as a temporary value that is remembered and used later.

Now, my regular schedule starts being evaluated, which, of course,
is different for every room. Rules are evaluated just as normal. If
one returns a result, that is used as the temperature and evaluation
stops. But wait, there was the ``Add(-3)``, wasn't it? Hence ``-3``
is now added to the final result.

With this minimal configuration effort, I added an useful away-mode
which throttles all thermostats in the house as soon as I leave.

Think of a device tracker that is able to report the distance between
you and your home. Having such one set up, you could even implement
dynamic throttling that slowly decreases as you near with almost zero
configuration effort.


Example: Including Schedules Dynamically with ``IncludeSchedule()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``IncludeSchedule()`` result type for expressions can be used to
insert a set of schedule rules right at the position of the current
rule. This comes handy when a set of rules needs to be chosen depending
on the state of entities or is reused in multiple rooms.

.. note::

   If you just want to prevent yourself from repeating the same
   static constraints for multiple rules that are used only
   once in your configuration, use the `sub-schedule feature
   <writing-schedules.html#rules-with-sub-schedules>`_ of the normal
   rule syntax instead.

You can reference any schedule defined under ``schedule_snippets`` in
the configuration, hence we create one to play with for our heating setup:

::

    schedule_snippets:
      summer:
      - { v: 20, start: "07:00", end: "22:00", weekdays: 1-5 }
      - { v: 20, start: "08:00", weekdays: 6-7 }
      - { v: 16 }

Now, we include the snippet into a room's schedule:

::

    schedule:
    - x: IncludeSchedule(schedule_snippets["summer"])
      months: 6-9
    - { v: 21, start: "07:00", end: "21:30", weekdays: 1-5 }
    - { v: 21, start: "08:00", end: "23:00", weekdays: 6-7 }
    - { v: 17 }

It turns out that you could have done the exact same without including
schedules by adding the ``months: 6-9`` constraint to all rules of the
summer snippet. But doing it this way makes the configuration a little
more readable.

However, you can also utilize the include functionality from inside
custom code. Just think of a function that selects different schedules
based on external criteria, such as weather sensors or presence detection.

.. note::

   Splitting up schedules doesn't bring any extra power to Schedy's
   scheduling capabilities, but it can make configurations much more
   readable as they grow.


Example: What to Use ``Break()`` for
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When in a sub-schedule, returning ``Break()`` from an expression will
skip the remaining rules of that sub-schedule and continue evaluation
after it. You can use it together with ``Skip()`` to create a conditional
sub-schedule, for instance.

::

    schedule:
    - v: 20
      rules:
      - x: Skip() if is_on("input_boolean.include_sub_schedule") else Break()
      - { start: "07:00", end: "09:00" }
      - { start: "12:00", end: "22:00" }
      - v: 17
     - v: "OFF"

The rules 2-4 of the sub-schedule will only be respected when
``input_boolean.include_sub_schedule`` is on. Otherwise, evaluation
continues with the last rule, setting the value to ``OFF`` (which only
exists with the thermostat actor type).

The actual definition of this result type is ``Break(levels=1)``,
which means that you may optionally pass a parameter called ``levels``
to ``Break()``. This parameter controls how many levels of nested
sub-schedules to break out of. The implicit default value ``1`` will
only abort the innermost sub-schedule (the one currently in). However,
you may want to directly abort its parent schedule as well by returning
``Break(2)``. In the above example, this would actually break the
top-level schedule and hence abort the entire schedule evaluation.

.. note::

   Returning ``Break()`` in the top-level schedule is equivalent to
   returning ``Abort()``.


Example: What to Use ``Abort()`` for
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``Abort`` return type is most useful for disabling Schedy's
scheduling mechanism depending on the state of entities. You might
implement a schedule on/off switch with it, like so:

::

    schedule_prepend:
    - x: Abort() if is_off("input_boolean.schedy") else Skip()

As soon as ``Abort()`` is returned, schedule evaluation is aborted and
the value stays unchanged.


Security Considerations
-----------------------

It has to be noted that expressions are evaluated using Python's
``exec()`` function. In general, this is not suited for code
originating from a source you don't trust completely, because such
code can potentially execute arbitrary commands on your system with
the same permissions and capabilities the AppDaemon process itself
has. That shouldn't be a problem for expressions you write yourself
inside schedules.

This feature could however become problematic if an attacker somehow
is able to emit events on your Home Assistant's event bus. To prevent
expressions from being accepted in the ``schedy_set_value`` event,
processing of such expressions is disabled by default and has to be
enabled explicitly by setting ``expressions_from_events: true`` in your
Schedy configuration.
